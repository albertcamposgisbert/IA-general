// Generated by CoffeeScript 1.10.0
(function() {
  var H, countChars, defaults, fsmHelper, imodes, modes, ownGUIs, removeChildren, themes,
    slice = [].slice,
    hasProp = {}.hasOwnProperty;

  modes = {
    latex: "text/x-latex",
    lua: "text/x-lua",
    antlrlex: "text/antlrlex",
    antlrsyn: "text/antlrsyn",
    cfg: "text/cfg",
    dfa: "text/dfa",
    opcf: "text/opcf",
    opreg: "text/opreg",
    pda: "text/pda",
    redcfg: "text/redcfg",
    redcfgsol: "text/redcfg-sol",
    redk: "text/redk",
    rednp: "text/rednp",
    redsat: "text/redsat",
    redwp: "text/redwp"
  };

  imodes = {
    antlrlex: ["antlrlex"],
    antlrsyn: ["antlrsyn"],
    cfg: ["cfg", "pda"],
    dfa: ["dfa", "opreg"],
    opcf: ["opcf"],
    opreg: ["opreg"],
    pda: ["cfg", "pda"],
    redcfg: ["redcfgsol"],
    redk: ["lua"],
    rednp: ["rednp"],
    redsat: ["lua"],
    redwp: ["lua"]
  };

  themes = {
    light: true,
    dark: true
  };

  defaults = {
    mode: "cfg",
    theme: "light",
    focus: false,
    width: 600,
    height: 0,
    charsGUI: false,
    modesGUI: false,
    themesGUI: false,
    fullscreenGUI: true,
    linenumbersGUI: true,
    editcallback: null
  };

  countChars = function(t) {
    var decode_utf8, encode_utf8;
    encode_utf8 = function(t) {
      return unescape(encodeURIComponent(t));
    };
    decode_utf8 = function(e) {
      return decodeURIComponent(escape(e));
    };
    return (encode_utf8(t)).length;
  };

  removeChildren = function(n) {
    while (n.firstChild != null) {
      n.removeChild(n.firstChild);
    }
    return n;
  };

  H = function() {
    var attributes, child, children, k, kind, kk, l, len, res, v, vv;
    kind = arguments[0], attributes = arguments[1], children = 3 <= arguments.length ? slice.call(arguments, 2) : [];
    if (attributes == null) {
      return document.createTextNode(kind);
    } else {
      res = document.createElement(kind);
      for (k in attributes) {
        if (!hasProp.call(attributes, k)) continue;
        v = attributes[k];
        if (k === "type") {
          res.setAttribute(k, v);
        } else if (k === "style") {
          for (kk in v) {
            if (!hasProp.call(v, kk)) continue;
            vv = v[kk];
            res[k][kk] = vv;
          }
        } else {
          res[k] = v;
        }
      }
      for (l = 0, len = children.length; l < len; l++) {
        child = children[l];
        if (typeof child === "string" || child instanceof String) {
          res.appendChild(document.createTextNode(child));
        } else {
          res.appendChild(child);
        }
      }
      return res;
    }
  };

  ownGUIs = {};

  if (typeof computeReachability !== "undefined" && computeReachability !== null) {
    ownGUIs.redwp = function(here) {
      var compute, expand, expanded, expandedDiv, gui, output, r, u, v;
      gui = H("table", {}, H("tr", {}, H("td", {
        style: {
          paddingLeft: "32px",
          verticalAlign: "top"
        }
      }, H("table", {}, H("tr", {
        title: "The word where the rewriting process starts"
      }, H("td", {
        style: {
          textAlign: "right"
        }
      }, H("Origin: ")), H("td", {}, u = H("input", {
        value: ""
      }))), H("tr", {
        title: "The desired destiny word of the rewriting process"
      }, H("td", {
        style: {
          textAlign: "right"
        }
      }, H("Destiny: ")), H("td", {}, v = H("input", {
        value: ""
      }))), H("tr", {
        title: "The rewrite rules to use (one rule per line, with format: originword -> rewrittenword)"
      }, H("td", {
        style: {
          textAlign: "right",
          verticalAlign: "top"
        }
      }, H("Rules: ")), H("td", {}, r = H("textarea", {
        value: "",
        rows: "4",
        cols: "20"
      }))), H("tr", {}, H("td", {
        colSpan: "2",
        align: "center"
      }, compute = H("button", {
        type: "button",
        className: "simpleoptions-elem"
      }, H("Reachable?")))))), output = H("td", {
        style: {
          paddingLeft: "32px",
          verticalAlign: "top"
        }
      })));
      compute.onclick = function() {
        var error, i, l, message, ref, res, text;
        removeChildren(output);
        try {
          res = computeReachability(u.value, v.value, r.value);
          if (res === false) {
            output.appendChild(H("No derivation from \"" + u.value + "\" to \"" + v.value + "\" found (although some might exist; recall that this is an undecidable problem)."));
          } else {
            output.appendChild(H("The word \"" + u.value + "\" can reach \"" + v.value + "\" in, e.g., " + (res.length - 1) + " steps as follows:"));
            text = "     " + res[0];
            for (i = l = 1, ref = res.length; 1 <= ref ? l < ref : l > ref; i = 1 <= ref ? ++l : --l) {
              text += "\n  -> " + res[i];
            }
            output.appendChild(H("pre", {}, H(text)));
          }
        } catch (error) {
          message = error;
          alert(message);
        }
        return false;
      };
      here.appendChild(H("Check reachability between two words: "));
      here.appendChild(expand = H("button", {
        type: "button",
        className: "simpleoptions-elem"
      }, H("+")));
      here.appendChild(expandedDiv = H("div", {}));
      expanded = false;
      return expand.onclick = function() {
        expanded = !expanded;
        removeChildren(expand);
        removeChildren(expandedDiv);
        if (!expanded) {
          expand.appendChild(H("+"));
        } else {
          expand.appendChild(H("-"));
          expandedDiv.appendChild(gui);
        }
        return false;
      };
    };
  }

  if (typeof cfgDerivations !== "undefined" && cfgDerivations !== null) {
    ownGUIs.cfg = function(here, _, getCurrentValue) {
      var compute, expand, expanded, expandedDiv, gui, output, w;
      gui = H("table", {}, H("tr", {}, H("td", {
        style: {
          paddingLeft: "32px",
          verticalAlign: "top"
        }
      }, H("table", {}, H("tr", {
        title: "The word to test whether it is generated or not by the current grammar"
      }, H("td", {
        style: {
          textAlign: "right"
        }
      }, H("Word: ")), H("td", {}, w = H("input", {
        value: ""
      }))), H("tr", {}, H("td", {
        colSpan: "2",
        align: "center"
      }, compute = H("button", {
        type: "button",
        className: "simpleoptions-elem"
      }, H("Generated?")))))), output = H("td", {
        style: {
          paddingLeft: "32px",
          verticalAlign: "top"
        }
      })));
      compute.onclick = function() {
        var error, i, j, l, message, o, ref, ref1, res, text;
        removeChildren(output);
        try {
          res = cfgDerivations(getCurrentValue(), w.value);
          if (res.length === 0) {
            output.appendChild(H("The grammar does not generate the word \"" + w.value + "\"."));
          } else {
            if (res.length === 1) {
              output.appendChild(H("The grammar unambiguously generates the word \"" + w.value + "\" with this left-most derivation:"));
            } else {
              output.appendChild(H("The grammar ambiguously generates the word \"" + w.value + "\" with, at least, these left-most derivations:"));
            }
            text = "";
            for (i = l = 0, ref = res.length; 0 <= ref ? l < ref : l > ref; i = 0 <= ref ? ++l : --l) {
              if (i !== 0) {
                text += "\n\n";
              }
              text += "  " + res[i][0] + " => ";
              for (j = o = 1, ref1 = res[i].length; 1 <= ref1 ? o < ref1 : o > ref1; j = 1 <= ref1 ? ++o : --o) {
                if (j !== 1) {
                  text += "\n    => ";
                }
                text += res[i][j];
              }
            }
            output.appendChild(H("pre", {}, H(text)));
          }
        } catch (error) {
          message = error;
          alert(message);
        }
        return false;
      };
      here.appendChild(H("Check whether a word is generated by the current CFG: "));
      here.appendChild(expand = H("button", {
        type: "button",
        className: "simpleoptions-elem"
      }, H("+")));
      here.appendChild(expandedDiv = H("div", {}));
      expanded = false;
      return expand.onclick = function() {
        expanded = !expanded;
        removeChildren(expand);
        removeChildren(expandedDiv);
        if (!expanded) {
          expand.appendChild(H("+"));
        } else {
          expand.appendChild(H("-"));
          expandedDiv.appendChild(gui);
        }
        return false;
      };
    };
  }

  if (typeof setupFSMEditor !== "undefined" && setupFSMEditor !== null) {
    ownGUIs.dfa = function(here, proxy) {
      return fsmHelper(here, proxy, true);
    };
    ownGUIs.pda = function(here, proxy) {
      return fsmHelper(here, proxy, false);
    };
    fsmHelper = function(here, proxy, isDFA) {
      var feedbackDiv, fsmOutputArea, switchMode, visualMode;
      feedbackDiv = H("div", {}, H("br", {}), H("Usage:"), H.apply(null, ["ul", {}, H("li", {}, H("b", {}, H("Add a state: ")), H("double-click on background.")), H("li", {}, H("b", {}, H("Add a transition: ")), H("shift-drag from a state to a state.")), H("li", {}, H("b", {}, H("Make a starting state: ")), H("shift-drag from background to a state.")), H("li", {}, H("b", {}, H("Make an accepting state: ")), H("double-click on a state."))].concat(slice.call((!isDFA ? [H("li", {}, H("The initial stack symbol is Z."))] : [])))), H("Automaton encoded in text:"), fsmOutputArea = H("div", {
        className: "fsm_output_data"
      }));
      here.appendChild(switchMode = H("button", {
        type: "button",
        className: "simpleoptions-elem"
      }, H("Switch to visual editor")));
      visualMode = false;
      switchMode.onclick = function() {
        visualMode = !visualMode;
        removeChildren(switchMode);
        if (visualMode) {
          switchMode.appendChild(H("Switch to text editor"));
          here.appendChild(feedbackDiv);
          proxy.setupVisual(fsmOutputArea);
        } else {
          switchMode.appendChild(H("Switch to visual editor"));
          proxy.unsetupVisual();
          here.removeChild(feedbackDiv);
        }
        return false;
      };
      if (proxy.encoded != null) {
        return switchMode.onclick();
      }
    };
  }

  (typeof exports !== "undefined" && exports !== null ? exports : this).racsoEditor = function(textarea, config) {
    var bottomDiv, canvas, cm, container, createCodemirror, createVisual, defaultMode, defaultTheme, divappend, editMode, extraGUI, fsm, getCurrentValue, k, m, refocus, selMode, selTheme, selectableModes, setCodemirrorMode, setFullscreen, setMode, setSizeText, setTheme, sizetext, sortedThemes, switchEditMode, t, textareaOldValue, v;
    if (config == null) {
      config = {};
    }
    if ((config.imode == null) || !(config.imode in imodes) || (imodes[config.imode] == null)) {
      selectableModes = (function() {
        var results;
        results = [];
        for (k in modes) {
          if (!hasProp.call(modes, k)) continue;
          results.push(k);
        }
        return results;
      })();
      selectableModes.sort();
    } else {
      selectableModes = imodes[config.imode];
      config.modesGUI = selectableModes.length > 1;
      config.mode = selectableModes[0];
    }
    if ((config.mode == null) || !(config.mode in modes)) {
      config.modesGUI = true;
      config.mode = defaults.mode;
    }
    if ((config.theme == null) || !(config.theme in themes)) {
      if (config.theme != null) {
        config.themesGUI = true;
      }
      config.theme = defaults.theme;
    }
    for (k in defaults) {
      if (!hasProp.call(defaults, k)) continue;
      v = defaults[k];
      if (config[k] == null) {
        config[k] = v;
      }
    }
    container = H("div", {
      className: "editor-container",
      style: {
        boxSizing: "content-box",
        width: config.width + "px"
      }
    });
    if (typeof textarea === "string" || textarea instanceof String) {
      textarea = document.getElementById(textarea);
    }
    textarea.wrap = "soft";
    textarea.parentNode.replaceChild(container, textarea);
    container.appendChild(textarea);
    bottomDiv = null;
    divappend = function(e) {
      if (bottomDiv == null) {
        bottomDiv = H("div", {
          className: "simpleoptions",
          style: {
            width: config.width + "px"
          }
        });
      } else {
        bottomDiv.appendChild(H("span", {
          className: "simpleoptions-elem simpleoptions-sep"
        }));
      }
      bottomDiv.appendChild(e);
      return e.className += " simpleoptions-elem";
    };
    if (config.charsGUI) {
      sizetext = H("span", {});
      setSizeText = function(t) {
        return (removeChildren(sizetext)).appendChild(H("Chars: " + (countChars(t))));
      };
      setSizeText(textarea.value);
      divappend(sizetext);
    }
    if (config.modesGUI) {
      defaultMode = config.mode;
      selMode = H.apply(null, ["select", {}, H("option", {}, H("Mode (" + defaultMode + ")"))].concat(slice.call((function() {
        var l, len, results;
        results = [];
        for (l = 0, len = selectableModes.length; l < len; l++) {
          m = selectableModes[l];
          results.push(H("option", {}, H(m)));
        }
        return results;
      })())));
      selMode.onchange = function() {
        var ref;
        config.mode = (ref = selectableModes[selMode.selectedIndex - 1]) != null ? ref : defaultMode;
        setMode();
        refocus();
        return false;
      };
      divappend(selMode);
    }
    if (config.themesGUI) {
      sortedThemes = (function() {
        var results;
        results = [];
        for (k in themes) {
          if (!hasProp.call(themes, k)) continue;
          results.push(k);
        }
        return results;
      })();
      sortedThemes.sort();
      defaultTheme = config.theme;
      selTheme = H.apply(null, ["select", {}, H("option", {}, H("Theme (" + defaultTheme + ")"))].concat(slice.call((function() {
        var l, len, results;
        results = [];
        for (l = 0, len = sortedThemes.length; l < len; l++) {
          t = sortedThemes[l];
          results.push(H("option", {}, H(t)));
        }
        return results;
      })())));
      selTheme.onchange = function() {
        var ref;
        config.theme = (ref = sortedThemes[selTheme.selectedIndex - 1]) != null ? ref : defaultTheme;
        setTheme();
        refocus();
        return false;
      };
      divappend(selTheme);
    }
    if (config.fullscreenGUI) {
      divappend(H("button", {
        type: "button",
        onclick: (function() {
          return setFullscreen(true);
        })
      }, H("Fullscreen")));
    }
    if (!(bottomDiv == null)) {
      container.appendChild(bottomDiv);
    }
    extraGUI = H("div", {
      className: "simpleoptions",
      style: {
        width: config.width + "px"
      }
    });
    container.appendChild(extraGUI);
    cm = null;
    createCodemirror = function() {
      cm = CodeMirror.fromTextArea(textarea, {
        autofocus: config.focus,
        lineNumbers: config.linenumbersGUI,
        lineWrapping: false,
        theme: config.theme,
        tabSize: 8,
        indentWithTabs: true,
        styleActiveLine: true,
        extraKeys: {}
      });
      cm.setSize("" + config.width, (config.height <= 0 ? null : "" + config.height));
      if (config.charsGUI || (config.editcallback != null)) {
        return cm.on("change", (function() {
          var currentValue;
          currentValue = cm.getValue();
          if (config.charsGUI) {
            setSizeText(currentValue);
          }
          if (config.editcallback != null) {
            return config.editcallback(currentValue);
          }
        }));
      }
    };
    setCodemirrorMode = function() {
      var ek, hint, key, ref, ref1;
      cm.setOption("mode", modes[config.mode]);
      ek = {
        "F11": (function() {
          return setFullscreen(!cm.getOption("fullScreen"));
        }),
        "Esc": (function() {
          return setFullscreen(false);
        })
      };
      ref1 = (ref = CodeMirror.mimeModes[modes[config.mode]].autocompleteHinting) != null ? ref : {};
      for (key in ref1) {
        if (!hasProp.call(ref1, key)) continue;
        hint = ref1[key];
        ek[key] = hint;
      }
      return cm.setOption("extraKeys", ek);
    };
    fsm = null;
    canvas = null;
    createVisual = function(isDFA, fsmOutputArea, encoded, encodedCallback) {
      var callbackCurrent, h;
      h = config.height <= 0 ? 400 : config.height;
      canvas = H("canvas", {
        className: "fsm_canvas",
        width: config.width,
        height: h,
        style: {
          width: config.width + "px",
          height: h + "px"
        }
      });
      container.insertBefore(canvas, textarea);
      textarea.style.display = "none";
      callbackCurrent = function(automaton, encoded) {
        textarea.value = automaton;
        if (config.charsGUI) {
          setSizeText(automaton);
        }
        if (config.editcallback != null) {
          config.editcallback(automaton);
        }
        if (encodedCallback != null) {
          return encodedCallback(encoded);
        }
      };
      return fsm = setupFSMEditor(canvas, config.theme, isDFA, fsmOutputArea, callbackCurrent, encoded);
    };
    editMode = "codemirror";
    textareaOldValue = null;
    switchEditMode = function(to, isDFA, fsmOutputArea, encoded, encodedCallback) {
      if (to === "codemirror") {
        if (editMode !== "codemirror") {
          editMode = to;
          fsm.deattach();
          fsm = null;
          container.removeChild(canvas);
          canvas = null;
          textarea.value = textareaOldValue;
          textareaOldValue = null;
          createCodemirror();
          setCodemirrorMode();
          if (config.charsGUI) {
            return setSizeText(textarea.value);
          }
        }
      } else {
        if (editMode === "codemirror") {
          editMode = to;
          cm.toTextArea();
          cm = null;
          textareaOldValue = textarea.value;
          return createVisual(isDFA, fsmOutputArea, encoded, encodedCallback);
        }
      }
    };
    refocus = function() {
      if (editMode === "codemirror") {
        return cm.focus();
      }
    };
    setFullscreen = function(st) {
      if (editMode === "codemirror") {
        if ((cm.getOption("fullScreen")) !== st) {
          cm.setOption("fullScreen", st);
        }
        return refocus();
      } else {
        return fsm.setFullscreen(st);
      }
    };
    setTheme = function() {
      if (editMode === "codemirror") {
        return cm.setOption("theme", config.theme);
      } else {
        return fsm.setTheme(config.theme);
      }
    };
    getCurrentValue = function() {
      if (editMode === "codemirror") {
        return cm.getValue();
      } else {
        return textarea.value;
      }
    };
    setMode = function() {
      var extracted, proxy;
      switchEditMode("codemirror");
      setCodemirrorMode();
      removeChildren(extraGUI);
      if (config.mode in ownGUIs) {
        proxy = {};
        if (config.mode === "dfa" || config.mode === "pda") {
          extracted = magicFSMtext(cm.getValue());
          if (extracted != null) {
            proxy.encoded = extracted.encoded;
            cm.setValue(extracted.compiled);
          }
          proxy.setupVisual = function(fsmOutputArea) {
            return switchEditMode("visualeditor", config.mode === "dfa", fsmOutputArea, proxy.encoded, (function(encoded) {
              return proxy.encoded = encoded;
            }));
          };
          proxy.unsetupVisual = function() {
            return switchEditMode("codemirror");
          };
        }
        return ownGUIs[config.mode](extraGUI, proxy, getCurrentValue);
      }
    };
    createCodemirror();
    setMode();
    return {
      getValue: (function() {
        return getCurrentValue();
      })
    };
  };

}).call(this);
